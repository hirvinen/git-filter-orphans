#!/bin/bash
set -e
GIT_FILTER_ORPHANS_FIND(){
	##create a list of all blobs
	echo -e "building indexes\n"
	declare -A fileIndex
	declare -A bigObjectIndex
	declare -A uniqueObjectIndex
	declare -A allShasIndex

	#build list of all files in index
	list=`git ls-files | awk '{print "./"$1}'`
	while read -r file; do
		uniqueObjectIndex["$file"]=1
	done <<< "$list"

	#build an index of every sha->file
	allShas=`git rev-list --objects --all | sed -n 's/\w ./&/p'`
	while read -r line; do
		SHA=${line% *}
		FILE=${line#* }
		allShasIndex["$SHA"]="./$FILE"
	done <<< "$allShas"

	#build an index of sha->size
	bigObjects=`git gc && git verify-pack -v .git/objects/pack/pack-*.idx | sed -n 's/\(\w\+\) blob\W\+\([0-9]\+\) .*/\1 \2/p'`
	while read -r line; do
		SHA=${line% *}
		SIZE=${line#* }
		bigObjectIndex["$SHA"]=$SIZE
	done <<< "$bigObjects"

	: >$SORT_FILE
	#sort out any objects they are still in the repo
	#create a gfo-sorted.txt file
	count=0
	for SHA in "${!bigObjectIndex[@]}"; do
		FILE=${allShasIndex["$SHA"]}
		SIZE=${bigObjectIndex["$SHA"]}
		if [ -z "$FILE" ]; then
			continue
		fi
		if [[ ! ${uniqueObjectIndex["$FILE"]} ]]; then
			count=$((count+1))
			uniqueObjectIndex["$FILE"]=1
			echo 'indexed: ' $FILE
			echo "$SIZE $FILE" >> "$SORT_FILE"
		fi
	done;
	sort -nrk1 "$SORT_FILE" -o "$SORT_FILE"
	echo "$count files indexed in $SORT_FILE"
}

#eradicate a list of files and directories from existence
GIT_FILTER_ORPHANS_PURGE(){
	args=("$@")
	tmp=""
	file="${args[0]}"
	treeFilter="$REPO_ROOT/.gfo.filter.tree"
	indexFilter="$REPO_ROOT/.gfo.filter.index"
	: > "$treeFilter"
	: > "$indexFilter"
	chmod +x "$treeFilter"
	chmod +x "$indexFilter"
	if [ ${#args[@]} -eq 2 ]; then
		tmp="${args[1]}"
	fi
	cat "$file" | while read line; do
		file=${line#* }
		echo "rm -f \"$file\"" >> "$treeFilter"
		echo "git rm --cached --ignore-unmatch \"$file\"" >> "$indexFilter"
	done

   	cmd=(--force --prune-empty)
	if [ ! -z "$tmp" ]; then
		cmd+=(-d "$tmp")
	fi
	cmd+=(--tree-filter "\"$treeFilter\"")
	cmd+=(--index-filter "\"$indexFilter\"")
	cmd+=(--tag-name-filter cat -- --all)
	echo "${cmd[@]}" | xargs git filter-branch
	rm -f "$treeFilter" "$indexFilter"
}

#eradicate the file or directory from existence
GIT_FILTER_ORPHANS_FILTER(){
	args=("$@")
	tmp=""
	file="${args[0]}"
	if [ ${#args[@]} -eq 2 ]; then
		tmp="${args[1]}"
	fi
   	cmd=(--force --prune-empty)
	if [ ! -z "$tmp" ]; then
		cmd+=(-d '"'"$tmp"'"')
	fi
	cmd+=(--tree-filter "'rm -f \"$file\"'")
	cmd+=(--index-filter "'git rm --cached --ignore-unmatch \"$file\"'")
	cmd+=(--tag-name-filter cat -- --all)
	echo "${cmd[@]}" | xargs git filter-branch
}

#recursively removes the directory from existence
GIT_FILTER_ORPHANS_RMDIR(){
	args=("$@")
	tmp=""
	file="${args[0]}"
	if [ ${#args[@]} -eq 2 ]; then
		tmp="${args[1]}"
	fi
   	cmd=(--force --prune-empty)
	if [ ! -z "$tmp" ]; then
		cmd+=(-d '"'"$tmp"'"')
	fi
	#recursive
	cmd+=(--tree-filter "'rm -rf \"$file\"'")
	cmd+=(--index-filter "'git rm -rf --cached --ignore-unmatch \"$file\"'")
	cmd+=(--tag-name-filter cat -- --all)
	echo "${cmd[@]}" | xargs git filter-branch
	if [ $? -gt 0 ]; then
		echo "file: $file not found in tree, recursing..."
		exit
	fi
	echo 'Filter complete!'
}

#expire old refs and run garbage collection
GIT_FILTER_ORPHANS_GC(){
	if [ -d ".git/refs/original" ]; then
		echo 'deleting backup references'
		set +e
		git for-each-ref --format='%(refname)' refs/original | xargs -n 1 git update-ref -d
		set -e
	fi
	echo 'expiring reflog'
	git reflog expire --expire=now --all
	git gc --prune=now --aggressive
	rm -rf .git/refs/original
}

#check out all remote branch refs
GIT_FILTER_ORPHANS_CHECKOUT(){
	echo 'Checking out branches'
	set +e
	git branch -r | tail -n +2 | while read remote;	do
		branch=${remote#*/}
		git checkout "$branch" 2>> /dev/null
	done
	set -e
	git checkout "$MAIN_BRANCH"
}

#update all refs and tags on remote
GIT_FILTER_ORPHANS_UPDATE(){
	echo "Updating repo: $REPO"
	if [ -d ".git/refs/original" ]; then
		GIT_FILTER_ORPHANS_GC
	fi
	git push --mirror
}

#refresh a filtered repo, move a backup of the current and reclone into CWD
GIT_FILTER_ORPHANS_CLONE(){
	bak="${REPO}.gfo.bak"
	tmp=".gfo.tmp"
	tmpbak="$bak"
	count=1
	while true; do
		if [ ! -d "$tmpbak" ]; then
			break
		fi
		count=$((count+1))
		tmpbak="${bak}_${count}"
	done
	bak="$tmpbak"
	echo "moving files to backup and cloning..."
	rm -rf "$tmp"
	mkdir "$bak"
	mkdir "$tmp"
	#move files to backup
	ls -A | grep -v "^$bak" | while read file; do
		mv "$file" "$bak/"
	done
	#clone into current dir
	git clone "file://$bak" "$tmp"
	ls -A "$tmp" | while read file; do
		mv "$tmp/$file" .
	done
	rmdir "$tmp"
	cp -f "$bak/.git/config" .git/
}

#parse arguments and call corresponding methods
GIT_FILTER_ORPHANS_PARSE(){
	argCount=${#args[@]}
	tmp=""
	#no args, show help
	if [ $argCount -eq 0 ]; then
		GIT_FILTER_ORPHANS_HELP
	else
		if [ $argCount -eq 4 ]; then
			case "${args[2]}" in
				--tmp)
					tmp="${args[3]}"
					;;
			esac
		fi
		case "${args[0]}" in
			find)
				GIT_FILTER_ORPHANS_FIND
				;;
			gc)
				GIT_FILTER_ORPHANS_GC
				;;
			clone)
				GIT_FILTER_ORPHANS_CLONE
				;;
			update)
				GIT_FILTER_ORPHANS_UPDATE
				;;
			checkout)
				GIT_FILTER_ORPHANS_CHECKOUT
				;;
			rmdir)
				if [ $argCount -lt 2 ]; then
					echo 'Error: Must provide a file or directory path with "rmdir"'
					exit 0
				fi
				GIT_FILTER_ORPHANS_CHECKOUT
				GIT_FILTER_ORPHANS_RMDIR "${args[1]}" "$tmp"
				;;
			filter)
				if [ $argCount -lt 2 ]; then
					echo 'Error: Must provide a file or directory path with "filter"'
					exit 0
				fi
				GIT_FILTER_ORPHANS_CHECKOUT
				GIT_FILTER_ORPHANS_FILTER "${args[1]}" "$tmp"
				;;
			purge) 
				if [ $argCount -lt 2 ]; then
					echo 'Error: Must provide a path to a gfo-sorted list file with "purge"'
					exit 0
				elif [ ! -f "${args[1]}" ]; then
				   	echo 'Error: No file found matching "'"${args[1]}"'"'
					exit 0
				fi
				GIT_FILTER_ORPHANS_CHECKOUT
				GIT_FILTER_ORPHANS_PURGE "${args[1]}" "$tmp"
				;;
			help)
				GIT_FILTER_ORPHANS_HELP "${args[@]:1}"
				;;
			*)
				echo 'Error: invalid parameter'
				exit 1
				;;
		esac
	fi
}

#git clone --no-hardlinks repo new
GIT_FILTER_ORPHANS(){
	local args=("$@")
	local CWD=`pwd`
	local SORT_FILE='gfo-sorted.txt'
	local REPO="`git config --get-regexp '.url' | head -n 1`"
	local REPO_ROOT=""
	local MAIN_BRANCH="`git branch | sed -n 's/\* \(.*\)/\1/p'`"
	#scope vars
	REPO=${REPO#*/}
	isBare=`git rev-parse --is-bare-repository`
	#get repo root
	if [ "$isBare" == "true" ]; then
		REPO_ROOT=`git rev-parse --git-dir`
		if [ "$REPO_ROOT" == "." ]; then
			REPO_ROOT="$CWD"
		fi
	else
		REPO_ROOT=`git rev-parse --show-toplevel`
	fi
	if [ -z "$REPO" ]; then
		#bypass error if help command
		case "${args[0]}" in
			help)
				GIT_FILTER_ORPHANS_CHECKOUT_BRANCHES
				GIT_FILTER_ORPHANS_HELP "${args[@]:1}"
				exit
				;;
		esac
		echo 'Error: not a git repo'
		echo 'use git-filter-branch -h'
		exit 0
	fi
	#chdir to repo root
	if [ "$REPO_ROOT" != "$CWD" ]; then
		echo "chdir $CWD -> $REPO_ROOT"
		cd "$REPO_ROOT"
	fi
	#parse params and call final method
	GIT_FILTER_ORPHANS_PARSE
}


#display help message
GIT_FILTER_ORPHANS_HELP(){
	args=("$@")
	GIT_USER="${args[0]}"
	CLONE_REPO="${args[1]}"
	if [ -z "$GIT_USER" ]; then
		GIT_USER="<username>"
	fi
	if [ -z "$CLONE_REPO" ]; then
		CLONE_REPO="<clone-repo>"
	fi
cat <<-EOL

Git-filter-orphans
==================

Git-filter-orphans will find all your orphaned objects and
eradicate them from your git history and repo completely.


COMMANDS
--------
  find         -find all orphan objects and store them in a list($SORT_FILE)
  update       -update your new repo and force push to remote
  clone        -make a backup of your current repo and clone from it in: $REPO_ROOT
  gc           -run manual garbage collection on repo (potentially dangerous)
  checkout     -checkout all remote branches
  purge FILE   -purge an object list, expects a gfo-sorted.txt type of list
    --tmp DIR    -an off-disk temporary directory to optimize the filter process
                  the directory will be created and deleted on completion
  filter PATH  -filter a single orphaned file or directory, will not recurse a directory
    --tmp DIR    -same as above
  rmdir PATH   -recursively filter all items of a directory
    --tmp DIR    -same as above
  help GIT-USERNAME CLONE-REPO
               -this menu, you can pass a username and clone-repo name into the params
                be used in place of <username> and <clone-repo> below
  Note: might be a good idea to test this on a cloned version of your repo


EXAMPLES
--------
  - build list file -> gfo-sorted.txt
  $ $REPO> ~/git-filter-orphans find

  - confirm contents of the generated list
  $ $REPO> cat gfo-sorted.txt

  - purge the list created in "gfo-sorted.txt":
  $ $REPO> ~/git-filter-orphans purge gfo-sorted.txt


COMPLETE GUIDE - READ FIRST
---------------------------
This assumes you want to create a clone of your repo for liability
purposes and have already created a new repo for this.

#create the clone
  $ > git clone --bare git@github.com:$GIT_USER/$REPO ${REPO}.git
  $ > cd ${REPO}.git
  $ ${REPO}.git> git push --mirror git@github.com:$GIT_USER/$CLONE_REPO

#clone the new remote repo
  $ ${REPO}.git> cd .. && git clone git@github.com:$GIT_USER/$CLONE_REPO && cd "$CLONE_REPO"

#create a $SORT_FILE file of orphaned objects and their size in bytes
  $ $CLONE_REPO> ~/git-filter-orphans find

#the $SORT_FILE looks good
#lets delete the items in it with git-filter-branch
  $ $CLONE_REPO> ~/git-filter-orphans purge $SORT_FILE

#now we have a clean repo ready to be pushed, this runs gc
  $ $CLONE_REPO> ~/git-filter-orphan update

EOL
	if [ "$CLONE_REPO" == "$REPO" ]; then
		echo "---"
		echo "Warning: Your target cloned repo is the same as your current!"		
		echo "---"
	fi
}

GIT_FILTER_ORPHANS $@

